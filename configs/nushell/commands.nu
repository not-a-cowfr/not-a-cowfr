# table of uncommited lines removed and added, good for egoing yourself with how much you overcomplicate things
export def "git lines" [
    --no-ansi (-n), # Disable ansi coloring in the table, allowing you to pipe into other commands that rely on the cell being an number
    --total (-t), # Only show the total diff, no table of each file
]: nothing -> table {
    if (git rev-parse --is-inside-work-tree | str trim) != "true" {
        return
    }

    let diff = (^git diff HEAD --numstat -M err> nul | lines | where $it =~ '^\d+\s+\d+\s+')

    if ($diff | is-empty) {
        print $"(ansi red_bold)No changes have been made!(ansi reset)"
        return
    }

    let stats = $diff
        | split column "\t" added removed file
        | each { |row| { file: $row.file, added: ($row.added | into int), removed: ($row.removed | into int) } }

    let total_added = $stats.added | math sum
    let total_removed = $stats.removed | math sum
    let net_diff = $total_added - $total_removed

    let diff_color = if $net_diff > 0 {
        $"+(ansi green)"
    } else if $net_diff == 0 {
        $"(ansi white)"
    } else {
        $"-(ansi red)"
    }

    print $"\n(ansi white_bold)Total:\n(ansi green)($total_added)(ansi reset) added\n(ansi red)($total_removed)(ansi reset) removed\n($diff_color)($net_diff | math abs)(ansi reset) diff"

    match $total {
        true => {
            if $no_ansi {
                print $"\n(ansi red)Why would you use no ansi to mess with the table data, and then remove the table data(ansi reset)"
            }
        },
        false => {
            print
            match $no_ansi {
                true => {
                    $stats
                },
                false => {
                    $stats | each { |row|
                        { file: $row.file,
                            added: $"(ansi green)($row.added)(ansi reset)",
                            removed: $"(ansi red)($row.removed)(ansi reset)" }
                    }
                },
            }
        },
    }
}

# Total line count across all non-gitignored files in the current directory
export def "git total lines" [
#     --include (-i): string, # Only include a certain file type, eg. --include .nu or -i rs
#     --exclude (-e): string, # Exclude a certain file type
#     --exclude-bloat (-eb): string, # Exclude files known to be autogenerated or bloat that shouldnt count as lines of code, eg. config files
    --total (-t), # Only show the total lines, no table of each file
]: nothing -> table {
    if (git rev-parse --is-inside-work-tree | str trim) != "true" {
        return
    }

    let lines = ^git ls-files | lines | each {|file| { file: $file, lines: (open --raw $file | lines | length) } }

    print $"\nTotal: (ansi green)($lines.lines | math sum)(ansi reset)"

    match $total {
        true => {},
        false => {
            print ""
            $lines
        }
    }
}

# Ever so slightly modified version of a script made by melmass on discord
# List binaries and examples in the current cargo workspace
export def "cargo targets" []: nothing -> table {
  let meta = (cargo metadata --no-deps --format-version 1 | from json)
  if ($meta | is-empty) {
    return []
  }
  let targets = ($meta | get packages.targets | flatten -a)

  let bins = ($targets | where ("bin" in $it.kind) | upsert kind "bin")
  let examples = ($targets | where ("example" in $it.kind) | upsert kind "example")

  $bins |
  | append $examples
  | select kind name src_path
  | rename kind name path
  | upsert path {|i| $i.path | path relative-to $meta.workspace_root }
}

export def "rm program" [
    program: string, # program to remove
    --no-confirm (-y), # skip confirmations
]: string -> nothing {
    let programs = which $program -a | each {|row| [$row.path $row.type] }
    if (($programs | is-empty)  ) {
        error make { msg: $"Program not found: ($program)" }
    } else {
        for program in $programs {
            if ($program.1) != "external" { continue }
            print ""

            if $no_confirm != true {
                let confirm = input $"Remove ($program.0)? \(Y/n\) "
                if $confirm == 'n' { continue }
            }

            rm $program.0
            print $"(ansi red)removed ($program.0)"
        }
    }
}

def test-api [
    endpoint: string, # endpoint to test
    server?: string, # server name
    requests: number = 100000, # number of requests to perform
]: any -> string {
    let rps = hey -n $requests -c 1000 $"http://localhost:3000/($endpoint)"
    | parse --regex '.*Requests/sec:\W+(?<rps>\d+)\.\d+'
    | get rps | get 0

    if ($server | is-not-empty) {
        print $"($server):"
    }
    $"($rps) requests/sec"
}

def "kill nginx" [] {
    sudo ss -tlnp
        | rg nginx
        | parse --regex ".*pid=(?<pid>\\d+).*"
        | get pid
        | uniq
        | each {|p|
            sudo kill ($p | into int)
        };
}

# create a new backup of a directory in ~/.backup
def "backup new" [
    path: path, # path of the directory to backup
    name?: string, # name override of the backup dir, by default it uses the dirname of what youre backing up
]: nothing -> nothing {
    let path = $path | path expand;

    let name: string  = ($name | default ($path | path basename));
    let backup_dir = $"~/.backup/($name)" | path expand;

    mkdir $backup_dir;
    let versions = (ls $backup_dir | where type == "dir" | get name | path basename)
    
    mut version = "v1";
    if ($versions | is-not-empty) {
        let version_num = (
            $versions
            | parse "v{num}"
            | get num
            | each { $in | into int }
            | math max
        ) + 1;
        
        $version = $"v($version_num)";
    }
    
    let version_dir = $"($backup_dir)/($version)/";

    mkdir $version_dir;
    for item in (ls $path | get name) {
        print $"Copying ($item)";
        cp -r $item $version_dir;
    }
}

# opens a select menu to reuild and switch nixos and/or home-manager
def "nix rebuild" [] {
    let choices = ["nixos", "home-manager", "config flake"]
    let selected = ($choices | str join "\n" | fzf --multi | lines)

    let user = (whoami | str trim)
    let host = (hostname | str trim)
    
    if ($selected | any {|x| $x == "nixos"}) {
        sudo nixos-rebuild switch --flake $"/etc/nixos#($host)"
    }

    # put this before home manager command so that if both are selected the flake updates first so home manager doesnt get a bunch of errors
    if ($selected | any {|x| $x == "config flake"}) {
        sudo nix flake update --flake /etc/nixos
    }

    if ($selected | any {|x| $x == "home-manager"}) {
        home-manager switch --flake $"/etc/nixos#($user)@($host)" --impure
    }
}

# opens a select menu of nixos generations to remove
def "nix remove-generations" [] {
    let generations = nix list-generations | where not isActive;
    
    let selected = $generations | get generation | str join "\n" | fzf --multi | lines | into int;

    if ($selected != null) {
        sudo nix-env -p /nix/var/nix/profiles/system --delete-generations ...$selected
    }
}

def "nix list-generations" []: nothing -> table {
    nixos-rebuild list-generations
        | parse --regex "(?<generation>\\d+)\\s+(?<buildDate>[-\\d]+ [:\\d]+)\\s+(?<nixosVersion>[\\.\\w]+)\\s+(?<kernalVersion>[\\.\\d]+)\\s+(?<revision>\\w+)\\s+(?<specialisation>\\[.*\\])\\s+(?<isActive>True|False)"
        | update generation { into int }
        | update buildDate { into datetime }
        | update specialisation { from json }
        | update isActive { into bool }
}

let vscodium_root_flags = $"--no-sandbox --user-data-dir=/home/(whoami)/.config/VSCodium";

const config_dirs = {
    "starship": "~/.config/starship.toml",
    "alacritty": "~/.config/alacritty/alacritty.toml",
    "ghostty": "~/.config/ghostty/config",
    "nix": { dir: "/etc/nixos", sudo: true },
    "nixos": { dir: "/etc/nixos", sudo: true },
    "fastfetch": "~/.config/fastfetch",
}

# new config command to open predermined directories instead of only working for nushell
export def "config" [
    app: string, # name of the app you want to open the config for
]: nothing -> nothing {
    let editor = $env.config.buffer_editor;

    mut dir = $config_dirs | get $app;

    mut flags = "";
    mut sudo = ""

    if (($dir | describe) != "string") {
        let obj = $dir;
        $dir = $obj | get dir;
        if ($obj | get sudo) {
            $flags = $vscodium_root_flags;
            $sudo = "sudo "
        }
    }

    nu -c $"($sudo)($editor) ($dir) ($flags)"
}

# open the nu config dir instead of just config.nu
# has to be done like this because config nu clashes with the builtin
export def "config nu" []: nothing -> nothing {
    let editor = $env.config.buffer_editor;

    nu -c $"($editor) (dirname $nu.config-path)"
}

# lists files tracked by git along with some extra git-related data
def "git ls" [] {
    mut index = 1;
    let gitlog = git log --all --format="%ai" --name-only --diff-filter=ACMRT
    | split row "\n\n"
    | each {|i|
        let lines = $i | lines

        let last = $lines | last | into datetime

        $lines
        | drop
        | each {|file| {name: $file commit-ts: $last} }
    }
    | flatten
    | uniq-by name

    git ls-files | lines | wrap name | join $gitlog name --inner
}
