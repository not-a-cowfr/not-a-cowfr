# table of uncommited lines removed and added, good for egoing yourself with how much you overcomplicate things
export def "git lines" [
    --no-ansi (-n), # Disable ansi coloring in the table, allowing you to pipe into other commands that rely on the cell being an number
    --total (-t), # Only show the total diff, no table of each file
]: nothing -> table {
    if (git rev-parse --is-inside-work-tree | str trim) != "true" {
        return
    }

    let diff = (^git diff HEAD --numstat -M err> nul | lines | where $it =~ '^\d+\s+\d+\s+')

    if ($diff | is-empty) {
        print $"(ansi red_bold)No changes have been made!(ansi reset)"
        return
    }

    let stats = $diff
        | split column "\t" added removed file
        | each { |row| { file: $row.file, added: ($row.added | into int), removed: ($row.removed | into int) } }

    let total_added = $stats.added | math sum
    let total_removed = $stats.removed | math sum
    let net_diff = $total_added - $total_removed

    let diff_color = if $net_diff > 0 {
        $"+(ansi green)"
    } else if $net_diff == 0 {
        $"(ansi white)"
    } else {
        $"-(ansi red)"
    }

    print $"\n(ansi white_bold)Total:\n(ansi green)($total_added)(ansi reset) added\n(ansi red)($total_removed)(ansi reset) removed\n($diff_color)($net_diff | math abs)(ansi reset) diff"

    match $total {
        true => {
            if $no_ansi {
                print $"\n(ansi red)Why would you use no ansi to mess with the table data, and then remove the table data(ansi reset)"
            }
        },
        false => {
            print
            match $no_ansi {
                true => {
                    $stats
                },
                false => {
                    $stats | each { |row|
                        { file: $row.file,
                            added: $"(ansi green)($row.added)(ansi reset)",
                            removed: $"(ansi red)($row.removed)(ansi reset)" }
                    }
                },
            }
        },
    }
}

# Total line count across all non-gitignored files in the current directory
export def "git total lines" [
#     --include (-i): string, # Only include a certain file type, eg. --include .nu or -i rs
#     --exclude (-e): string, # Exclude a certain file type
#     --exclude-bloat (-eb): string, # Exclude files known to be autogenerated or bloat that shouldnt count as lines of code, eg. config files
    --total (-t), # Only show the total lines, no table of each file
]: nothing -> table {
    if (git rev-parse --is-inside-work-tree | str trim) != "true" {
        return
    }

    let lines = ^git ls-files | lines | each {|file| { file: $file, lines: (open --raw $file | lines | length) } }

    print $"\nTotal: (ansi green)($lines.lines | math sum)(ansi reset)"

    match $total {
        true => {},
        false => {
            print ""
            $lines
        }
    }
}

# Ever so slightly modified version of a script made by melmass on discord
# List binaries and examples in the current cargo workspace
export def "cargo targets" []: nothing -> table {
  let meta = (cargo metadata --no-deps --format-version 1 | from json)
  if ($meta | is-empty) {
    return []
  }
  let targets = ($meta | get packages.targets | flatten -a)

  let bins = ($targets | where ("bin" in $it.kind) | upsert kind "bin")
  let examples = ($targets | where ("example" in $it.kind) | upsert kind "example")

  $bins |
  | append $examples
  | select kind name src_path
  | rename kind name path
  | upsert path {|i| $i.path | path relative-to $meta.workspace_root }
}

# append a variable to an env var
export def --env "env add" [
    var: string, # the variable to add to
    value: string, # new variable to add
]: any -> nothing {
    let current = $env | get $var
    let new = $current | append $value
    load-env { $var: $new }
}

export def "rm program" [
    program: string, # program to remove
    --no-confirm (-y), # skip confirmations
]: string -> nothing {
    let programs = which $program -a | each {|row| [$row.path $row.type] }
    if (($programs | is-empty)  ) {
        error make { msg: $"Program not found: ($program)" }
    } else {
        for program in $programs {
            if ($program.1) != "external" { continue }
            print ""

            if $no_confirm != true {
                let confirm = input $"Remove ($program.0)? \(Y/n\) "
                if $confirm == 'n' { continue }
            }

            rm $program.0
            print $"(ansi red)removed ($program.0)"
        }
    }
}

def test-api [
    endpoint: string, # endpoint to test
    server?: string, # server name
    requests: number = 100000, # number of requests to perform
]: any -> string {
    let rps = hey -n $requests -c 100 $"http://localhost:3000/($endpoint)"
    | parse --regex '.*Requests/sec:\W+(?<rps>\d+)\.\d+'
    | get rps | get 0

    if ($server | is-not-empty) {
        print $"($server):"
    }
    $"($rps) requests/sec"
}